/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.buenosaires.u;

import entidades.User;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.Persistence;
import javax.persistence.Query;
import javax.swing.Icon;
import org.netbeans.api.settings.ConvertAsProperties;
import org.netbeans.spi.actions.AbstractSavable;
import org.openide.DialogDisplayer;
import org.openide.NotifyDescriptor;
import org.openide.NotifyDescriptor.Confirmation;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.awt.UndoRedo;
import org.openide.util.ImageUtilities;
import org.openide.util.Lookup;
import org.openide.util.LookupEvent;
import org.openide.util.LookupListener;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;
import org.openide.util.lookup.AbstractLookup;
import org.openide.util.lookup.InstanceContent;
import org.openide.windows.WindowManager;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//org.buenosaires.u//EditorUser//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "EditorUserTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE", 
        persistenceType = TopComponent.PERSISTENCE_ALWAYS
)
@TopComponent.Registration(mode = "editor", openAtStartup = true)
@ActionID(category = "Window", id = "org.buenosaires.u.EditorUserTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_EditorUserAction",
        preferredID = "EditorUserTopComponent"
)
@Messages({
    "CTL_EditorUserAction=EditorUser",
    "CTL_EditorUserTopComponent=EditorUser Window",
    "HINT_EditorUserTopComponent=This is a EditorUser window"
})

public final class EditorUserTopComponent extends TopComponent implements LookupListener{

    private Lookup.Result result = null;
    private InstanceContent content;
    private UndoRedo.Manager manager = new UndoRedo.Manager();
    private User user;
    public EditorUserTopComponent() {
        initComponents();
        setName(Bundle.CTL_EditorUserTopComponent());
        setToolTipText(Bundle.HINT_EditorUserTopComponent());
         content = new InstanceContent();
        associateLookup(new AbstractLookup(content));

        
        passwordField.getDocument().addUndoableEditListener(manager);
        usernameField.getDocument().addUndoableEditListener(manager);
        
        usernameField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyReleased(KeyEvent e) {
            modify();
            }
        });
        passwordField.addKeyListener(new KeyAdapter() {

            @Override
            public void keyReleased(KeyEvent e) {
            modify();
        }
    });

    }
    
    private void modify() {
    if (getLookup().lookup(MySavable.class) == null) {
        content.add(new MySavable());
    }
}
    
    @Override
    public void resultChanged(LookupEvent lookupEvent) {
        Lookup.Result r = (Lookup.Result) lookupEvent.getSource();
        Collection<User> coll = r.allInstances();
        if (!coll.isEmpty()) {
            for (User usr : coll) {
                user = usr;
                usernameField.setText(usr.getUsername());
                passwordField.setText(usr.getPassword());
            }
        } else {
            usernameField.setText("[sin nombre]");
            passwordField.setText("[sin password]");
        }
    }
    
    public void resetFields() {
    user = new User();
    usernameField.setText("");
    passwordField.setText("");
}
 

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        usernameField = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        passwordField = new javax.swing.JTextField();

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(EditorUserTopComponent.class, "EditorUserTopComponent.jLabel1.text")); // NOI18N

        usernameField.setText(org.openide.util.NbBundle.getMessage(EditorUserTopComponent.class, "EditorUserTopComponent.usernameField.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(EditorUserTopComponent.class, "EditorUserTopComponent.jLabel2.text")); // NOI18N

        passwordField.setText(org.openide.util.NbBundle.getMessage(EditorUserTopComponent.class, "EditorUserTopComponent.passwordField.text")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(94, 94, 94)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(18, 18, 18))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addGap(22, 22, 22)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(passwordField, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)
                    .addComponent(usernameField))
                .addGap(77, 77, 77))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(96, 96, 96)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(usernameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(passwordField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(148, Short.MAX_VALUE))
        );

        passwordField.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(EditorUserTopComponent.class, "EditorUserTopComponent.passwordField.AccessibleContext.accessibleName")); // NOI18N
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JTextField passwordField;
    private javax.swing.JTextField usernameField;
    // End of variables declaration//GEN-END:variables
       @Override
    public void componentOpened() {
        result = WindowManager.getDefault().findTopComponent("MantenedoresTopComponent").getLookup().lookupResult(User.class);
        result.addLookupListener(this);
        resultChanged(new LookupEvent(result));
    }

    @Override
    public void componentClosed() {
        result.removeLookupListener(this);
        result = null;
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }
    
    @Override
    public UndoRedo getUndoRedo() {
    return manager;
    }
    
    private static final Icon ICON = ImageUtilities.loadImageIcon("org/shop/editor/Icon.png", true);

private class MySavable extends AbstractSavable implements Icon {

    MySavable() {
        register();
    }

    @Override
    protected String findDisplayName() {
        String username = usernameField.getText();
        String password = passwordField.getText();
        return username;
    }

    @Override
    protected void handleSave() throws IOException {
        Confirmation message = new NotifyDescriptor.Confirmation("Â¿Desea guardar estos cambios \""
                + usernameField.getText() + " (" + passwordField.getText() + ")\"?",
                NotifyDescriptor.OK_CANCEL_OPTION,
                NotifyDescriptor.QUESTION_MESSAGE);
        Object result = DialogDisplayer.getDefault().notify(message);
        //When user clicks "Yes", indicating they really want to save,
        //we need to disable the Save action,
        //so that it will only be usable when the next change is made
        //to the JTextArea:
        if (NotifyDescriptor.YES_OPTION.equals(result)) {
            
            EntityManager entityManager = Persistence.createEntityManagerFactory("BuenosAiresPU").createEntityManager();
            entityManager.getTransaction().begin();
            if (user.getId() != null) {
                
                User c = entityManager.find(User.class, user.getId());
                c.setId(user.getId());
                c.setUsername(usernameField.getText());
                c.setPassword(passwordField.getText());
                entityManager.getTransaction().commit();
            }else{
                Query query = entityManager.createNamedQuery("User.findAll");
                List<User> resultList = query.getResultList();
                System.out.println("cantidad de usuarios: "+resultList.size());
                user.setId(null);
                user.setUsername(usernameField.getText());
                user.setPassword(passwordField.getText());
                //add more fields that will populate all the other columns in the table!
                entityManager.persist(user);
                entityManager.getTransaction().commit();
            
            }
            tc().content.remove(this);
            
            unregister();
        }
        
    }

    EditorUserTopComponent tc() {
        return EditorUserTopComponent.this;
    }

    
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof MySavable) {
            MySavable m = (MySavable) obj;
            return tc() == m.tc();
        }
        return false;
    }

    @Override
    public int hashCode() {
        return tc().hashCode();
    }

    @Override
    public void paintIcon(Component c, Graphics g, int x, int y) {
        ICON.paintIcon(c, g, x, y);
    }

    @Override
    public int getIconWidth() {
        return ICON.getIconWidth();
    }

    @Override
    public int getIconHeight() {
        return ICON.getIconHeight();
    }

}


}
